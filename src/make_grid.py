# This program was generated by "Generative Art Synthesizer"
# Generation date: 2024-05-22 08:27:53 UTC
# GAS change date: 2024-05-22 08:27:09 UTC
# GAS md5 hash: af6cf9188108f420e878048291877a32
# Python version: 3.10.13 (main, May 22 2024, 00:46:52) [Clang 15.0.0 (clang-1500.1.0.2.5)]
# For more information visit: https://github.com/volotat/GAS

# import python libraries
import os
import time
from typing import Callable  # OS version: default

import numpy as np  # Numpy version: 1.24.3
from PIL import Image  # PIL version: 10.3.0
from scipy.ndimage import gaussian_filter, zoom

from gen_scripts.script_1 import test_values
from src.audio import Audio

# set initial params
# SIZE = 384
SIZE = 600
# SIZE = 64
GRID_CHANNELS = 16

# Set the number of beats per layer and per rotation
BEATS_PER_LAYER = 12
BEATS_PER_ROTATE = 18
BEATS_PER_SPLIT = 24


def make_grid(audio: Audio, time_position: int, img_path: str, transform: Callable):
    img_path = f"{img_path}{os.path.basename(audio.filename)}_frame_{time_position}.png"
    spectrogram_slice = audio.get_spectrogram_slice(time_position)
    # Get the min and max frequencies at the given time position
    non_zero_mask = spectrogram_slice != 0
    non_zero_frequencies = audio.frequencies[non_zero_mask]
    freq_min = np.min(non_zero_frequencies)
    freq_max = np.max(non_zero_frequencies)

    # Divide the frequency range into 16 equal sub-ranges
    freq_ranges = np.linspace(freq_min, freq_max, GRID_CHANNELS + 1)

    # rms_divisor = 80
    fps = audio.time_index_ratio
    bpm = audio.bpm

    # Calculate the number of frames per beat
    frames_per_beat = int(round(fps * 60 / bpm))

    # Calculate the current beat
    current_beat = time_position // frames_per_beat

    # Change rms_divisor in a sin wave pattern in a range of 50 to 110 to create a pulsating effect
    # over the course of six beats
    rms_offset = 20
    rms_divisor = 90 + rms_offset * np.sin((time_position % frames_per_beat) / frames_per_beat * np.pi)

    # Calculate the volume for each frequency sub-range at the given time position
    volumes = []
    for i in range(16):
        # Filter the spectrogram to only include the frequencies in the current sub-range
        freq_mask = (audio.frequencies >= freq_ranges[i]) & (audio.frequencies < freq_ranges[i + 1])
        filtered_spectrogram = spectrogram_slice[freq_mask]

        # Calculate the RMS of the filtered spectrogram
        rms = np.sqrt(np.mean(np.square(filtered_spectrogram)))

        # Normalize the RMS to the range [-1, 1]
        volume = rms / rms_divisor - 1
        volumes.append(volume)

    grid = audio.get_grid_cache_item(time_position)
    if grid is not None:
        # Use the cached grid
        pass
    else:
        # Initialize the grid using the calculated volumes
        grid = np.zeros((SIZE, SIZE, GRID_CHANNELS))

        x = ((np.arange(SIZE) / (SIZE - 1) - 0.5) * 2).reshape((1, SIZE)).repeat(SIZE, 0)
        y = ((np.arange(SIZE) / (SIZE - 1) - 0.5) * 2).reshape((SIZE, 1)).repeat(SIZE, 1)

        # # Coefficients for each layer
        grid_pattern_coefficients = [
            (-0.6843560386636265, 0.11289729845424112),
            (-0.08331318897125395, 0.9644936496982643),
            (-0.10117393096057592, 0.6020134197082545),
            (-0.8746747741531835, -0.3877333481373424),
            (-0.17093438114139659, -0.25452747490570626),
            (-0.31237057143125035, -0.9887087653359412),
            (0.39002773937503155, 0.11283355596472378),
            (0.31017755927550295, 0.4903569525830378),
            (-0.9596806727949436, -0.37919586395259985),
            (0.4018845444754593, 0.9891796715388903),
            (0.021353772113686498, -0.8837998364059418),
            (0.7666563906829007, -0.4312164516092756),
            (0.26326359779525776, -0.8730124330958187),
            (-0.1508475518380885, -0.6376222455451626),
            (-0.8254253869138659, 0.2223387842215283),
            (0.7585706387503179, 0.7123538355667594),
        ]

        # Apply the coefficients to each layer of the grid
        for i in range(GRID_CHANNELS):
            # TO TEST just plot the volumes
            # grid[:,:,i] = volumes[i]
            # NEXT TEST scale x and y by the volume, but don't apply the coefficients
            # grid[:,:,i] = volumes[i] * (x + y) / 2
            # NEXT TEST apply the coefficients
            grid[:, :, i] = volumes[i] * (x * grid_pattern_coefficients[i][0] + y * grid_pattern_coefficients[i][1]) / 2

        # apply transformations to the grid
        grid = transform(grid)
        audio.save_grid_cache_item(time_position, grid)

    # create color space
    # def shift_colors(x, shift):
    #     res = x.copy()
    #     for i in range(x.shape[-1]):
    #         shift[i] = -shift[i]
    #         if shift[i] > 0: res[:,:,i] = (-np.abs(((x[:,:,i] + 1) / 2) ** (1 + shift[i]) - 1) ** (1 / (1 + shift[i])) + 1) * 2 - 1
    #         if shift[i] < 0: res[:,:,i] = np.abs((1 - (x [:,:,i]+ 1) / 2) ** (1 - shift[i]) - 1) ** (1 / (1 - shift[i])) * 2 - 1
    #     return test_values(res)

    # res = np.zeros((SIZE, SIZE, 3))
    # res += shift_colors(grid[:,:,0:1].repeat(3, -1), [1.9051033227672765, 5.840126592885189, 2.600399481167409])

    # res = res / 1
    # res = ((res + 1) / 2) ** 2.5
    # res = (res * 255).clip(0,255)

    # # save results
    # with Image.fromarray(np.uint8(res)) as im:
    #     im.save(img_path)
    # return img_path

    # Select one channel from the grid array
    # layer = grid[:,:,1]

    # Select the layer based on the current beat out of best layers
    best_layers = [1, 9, 8, 6]

    # always use the first layer for the first beat, otherwise
    # Select the layer based on the current beat
    if current_beat < BEATS_PER_LAYER:
        # Rotate the image once 90 degrees
        selected_layer_index = best_layers[0]
        layer = grid[:, :, selected_layer_index]
    else:
        num_quadrants = 1

        split_section = current_beat // BEATS_PER_SPLIT
        beat_in_split = current_beat % BEATS_PER_SPLIT
        rng_split = np.random.default_rng(split_section)
        if split_section % 2 == 1:
            quadrants = [4, 2]
            rng_split.shuffle(quadrants)
            if 0 <= beat_in_split < 12:
                num_quadrants = quadrants[0]
            elif 12 <= beat_in_split < 18:
                num_quadrants = quadrants[1]

        if num_quadrants == 1:
            change_layer_section = current_beat // BEATS_PER_LAYER
            change_layer_rng = np.random.default_rng(change_layer_section)
            selected_layer_index = best_layers[change_layer_rng.integers(len(best_layers))]
            layer = grid[:, :, selected_layer_index]
        else:
            rng_split.shuffle(best_layers)
            layer = np.zeros((SIZE, SIZE))
            for i in range(num_quadrants):
                selected_layer_index = best_layers[i]
                sub_layer = grid[:, :, selected_layer_index]
                if rng_split.random() < 0.2:
                    # Sometimes flip the same quadrant to the other side
                    sub_layer = np.fliplr(sub_layer)
                elif rng_split.random() < 0.1:
                    # Sometimes flip vertically
                    sub_layer = np.flipud(sub_layer)
                # Mask the sub_layer into a quadrant of the layer
                if num_quadrants == 2:
                    # Select only the left or right half of the layer
                    sub_layer = sub_layer[:, i * SIZE // num_quadrants : (i + 1) * SIZE // num_quadrants]
                    layer[:, i * SIZE // num_quadrants : (i + 1) * SIZE // num_quadrants] = sub_layer
                else:  # num_quadrants == 4
                    # Select only the top left, top right, bottom left, or bottom right quadrant of the layer
                    # Mask that into a quadrant of the layer
                    sub_layer = sub_layer[
                        i // 2 * SIZE // 2 : (i // 2 + 1) * SIZE // 2, i % 2 * SIZE // 2 : (i % 2 + 1) * SIZE // 2
                    ]
                    layer[i // 2 * SIZE // 2 : (i // 2 + 1) * SIZE // 2, i % 2 * SIZE // 2 : (i % 2 + 1) * SIZE // 2] = sub_layer 
            # Create a mask that is True along either just the x-axis or both the x-axis and y-axis
            blur_bandwidth = 30 # The width of the blur band
            blur_mask = np.zeros_like(layer, dtype=bool)
            blur_mask[SIZE-blur_bandwidth // 2:SIZE+blur_bandwidth // 2, :] = True  # Middle y-axis
            if num_quadrants != 2:
                blur_mask[:, SIZE-blur_bandwidth // 2:SIZE+blur_bandwidth // 2] = True  # Middle x-axis
            blurred = gaussian_filter(layer, sigma=1)
            layer[blur_mask] = blurred[blur_mask]
            # # Calculate the zoom factor
            # zoom_factor = SIZE / (SIZE * 2)
            # # Resize the layer back to its original size
            # layer = zoom(layer, zoom_factor)

    # Scale the layer to the range [0, 255]
    layer = np.rot90(layer, k=1)
    layer = (layer + 1) * 127.5

    # Rotate the layer every n beats, but only based on randomly seeding rng with
    # the current section so each section gets the same random value
    rotate_section = current_beat // BEATS_PER_ROTATE
    rotate_rng = np.random.default_rng(rotate_section)
    # Give a chance of rotating the layer every n beats except for the first section
    rotate_chance = 0.66
    if rotate_section > 0 and rotate_rng.random() < rotate_chance:
        # rotation = (section % 4) * 90
        # Use a sine function to calculate the rotation
        rotation = np.sin(rotate_section) * 180
        layer = np.rot90(layer, k=rotation // 90)

    # Convert the layer to an image and save it
    im = Image.fromarray(np.uint8(layer))
    im.save(img_path)

    return img_path

    # #save layers
    img = np.zeros((SIZE * 4, SIZE * 4))
    for j in range(GRID_CHANNELS):
        x = j % 4
        y = j // 4
        img[x * SIZE : (x + 1) * SIZE, y * SIZE : (y + 1) * SIZE] = grid[:, :, j]

    img = (img + 1) * 127.5
    im = Image.fromarray(np.uint8(img))
    im.save(img_path)
    return img_path
